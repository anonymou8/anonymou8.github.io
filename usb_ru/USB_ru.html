<p><link href="styles.css" rel="stylesheet"></p>

<p></p>


<h1>Микроконтроллеры семейства STM32F10x на 32-битном ядре ARM</h1>

<h1>Справочное руководство</h1>

<h2>23. Интерфейс Full-speed USB 2.0</h2>

<ul>
<li><a href="#intro">23.1. Введение</a></li>
<li><a href="#char">23.2. Основные характеристики</a></li>
<li><a href="#func">23.3. Описание функций USB</a>

<ul>
<li><a href="#block">23.3.1. Описание блоков USB</a></li>
</ul>
</li>
<li><a href="#prog">23.4. Соображения по программированию</a>

<ul>
<li><a href="#regular">23.4.1. Программирование обычного USB-устройства</a></li>
<li><a href="#reset">23.4.2. Системный сброс и Сброс при включении МК</a>

<ul>
<li><a href="#resusb">Сброс USB</a></li>
</ul>
</li>
<li><a href="#pbuf">Структура и использование Пакетных буферов</a></li>
<li><a href="#epinit">Инициализация Конечной точки</a></li>
<li><a href="#in">Пакеты IN (передача данных)</a></li>
<li><a href="#out">Пакеты OUT и SETUP (приём данных)</a></li>
<li><a href="#ctl">Управляющие (Control) передачи</a></li>
<li><a href="#dblbuf">23.4.3. Конечные точки с двойной буферизацией</a></li>
<li><a href="#iso">23.4.4. Изохронные (Isochronous) передачи</a></li>
<li><a href="#susp">23.4.5. События Приостановки/Возобновления (suspend/resume)</a></li>
</ul>
</li>
<li><a href="#regs">23.5. Регистры USB</a>

<ul>
<li><a href="#common">23.5.1. Общие регистры</a>

<ul>
<li><a href="#USB_CNTR">Управляющий регистр USB (control, USB_CNTR)</a></li>
<li><a href="#USB_ISTR">Регистр состояния прерываний USB (interrupt status, USB_ISTR)</a></li>
<li><a href="#USB_FNR">Регистр номера фрейма USB (frame number, USB_FNR)</a></li>
<li><a href="#USB_DADDR">Адрес устройства USB (device address, USB_DADDR)</a></li>
<li><a href="#USB_BTABLE">Адрес таблицы буферов (buffer table address, USB_BTABLE)</a></li>
</ul>
</li>
<li><a href="#epregs">23.5.2. Регистры Конечных точек</a>

<ul>
<li><a href="#USB_EPnR">Регистры КТ-n, n=[0..7] (USB endpoint n register, USB_EPnR)</a></li>
</ul>
</li>
<li><a href="#table">23.5.3. Таблица дескрипторов буферов</a>

<ul>
<li><a href="#USB_ADDRn_TX">Адрес буфера отправки n (USB_ADDRn_TX)</a></li>
<li><a href="#USB_COUNTn_TX">Количество отправляемых байтов n (USB_COUNTn_TX)</a></li>
<li><a href="#USB_ADDRn_RX">Адрес буфера приёма n (USB_ADDRn_RX)</a></li>
<li><a href="#USB_COUNTn_RX">Количество принятых байтов n (USB_COUNTn_RX)</a></li>
</ul>
</li>
<li><a href="#regmap">23.5.4. Карта регистров USB</a></li>
</ul>
</li>
</ul>


<p><a name="intro"></a></p>

<h3>23.1. Введение</h3>

<p>USB-периферия служит интерфейсом между полноскоростным USB 2.0 и шиной APB1.</p>

<p>Поддерживается Приостановка/Возобновление USB, позволяющая останавливать источники тактирования для досижения минимального энергопотребления.</p>

<p><a name="char"></a></p>

<h3>23.2. Основные характеристики</h3>

<ul>
<li>Соответстве спецификации Full-speed USB 2.0</li>
<li>Настраиваемое число Конечных точек — от 1 до 8</li>
<li>Генерация/проверка контрольной суммы CRC, NRZI-кодирование со вставкой дополнительного бита</li>
<li>Поддержка Изохронного режима</li>
<li>Двойная буферизация для Массивных/Изохронных (Bulk/Isochronous) конечных точек</li>
<li>Операция Приостановки/Возобновления работы USB</li>
<li>Синхронизация по фрейму</li>
</ul>


<p><em>В контроллерах плотности low, medium, high и XL интерфейсы USB и CAN делят между собой 512-байтный объём локальной SRAM, необходимый им для отправки и приёма данных и поэтому оба интерфейса не могут использоваться одновременно (USB и CAN должны иметь эксклюзивный доступ к этому участку памяти). Интерфейсы USB и CAN могут быть использованы в одном приложении, но не одновременно.</em></p>

<p><a name="func"></a></p>

<h3>23.3. Описание функций USB</h3>

<p>На рисунке 220 представлена блок-схема USB-периферии контроллера.</p>

<p><img src="220.png"></p>

<p>USB-периферия позволяет соединить пользовательскую фунцию микроконтроллера c ПК или другим хостом в соответствии со стандартом USB. Передача данных между хостом и МК происходит через локальную память для Пакетных буферов, к которой USB-периферия имеет непосредственный доступ. <em>(Размер такого участка должен соответствовать числу используемых Конечных точек и максимальному размеру USB-пакета.)</em> <strong>В контроллере размер локальной пакетной памяти составляет 512 байт*.</strong> Может быть реализовано до 16 однонаправленных либо до 8 двунаправленных Конечных точек.</p>

<p>* <em>— Локальная память Пакетных буферов расположена по адресу 0x40006000.</em></p>

<p>При общении с хостом USB-периферия отвечает за детектирование пакета-токена, приём и передачу данных, а так же за необходимое &ldquo;рукопожатие&rdquo;, в соответствии со стандартом USB. Оформление пакетов в транзакции происходит аппаратно, включая подсчёт и проверку CRC.</p>

<p>Для каждой Конечной точки существует свой блок описания буферов, указывающий на выделенный ей участок памяти, его размер либо требуемое число байтов для передачи. Если USB-периферия получит пакет-токен для существующей (valid) пары Функция/Конечная точка (КТ), то произойдёт соответствующая передача данных (если КТ настроена и если что-то нужно получиь/передать). Данные загружаются во внутренний 16-битный регистр USB-периферии и происходит доступ к назначенному буферу. После передачи всех данных, при необходимости, генерируется либо ожидается пакет-&ldquo;рукопожатие&rdquo;, в зависимости от напрвления передачи.</p>

<p>По окончании транзакции генерируется прерывание, специфичное для КТ, в котором читаются статусные регистры и/или вызываются другие обработчики. МК может определить:</p>

<ul>
<li>Конечную точку, которую следует обслужить;</li>
<li>тип состоявшейся транзакции;</li>
<li>были ли ошибки (вставки дополнительного бита, формата, CRC, протокола, отсутствия пакета ACK, переполнение/опустошение буфера).</li>
</ul>


<p>Для Изохронных и Массивных (Bulk) передач может быть рализована двойная буферизация, с той целью, чтобы USB-периферия могла беспрерывно пользоваться одним буфером пока ПО использует другой.</p>

<p>МК может быть переведён в режим низкого энергопотребления (SUSPEND), записью в управляющий регистр, если это требуется. В этот момент желательно отключить неиспользуемую периферию, тактирование USB так же может быть замедлено либо остановлено. Во время сниженного энергопотребления, активность на USB-входах будит контроллер асинхронно. Отдельный источник прерывания может быть подключен непосредственно к линии пробуждения, чтобы мгновенно возобновить нормальный режим тактирования, либо для реализации непосредственного отключения/возобновления тактирования.</p>

<p><a name="block"></a></p>

<h4>23.3.1. Описание блоков USB</h4>

<p>USB-периферия содержит следующие блоки:</p>

<ul>
<li><strong>Последовательный интерфейс (Serial Interface Engine, SIE)</strong>: В функции блока входят: распознавание паттерна синхронизации, вставка дополнительного бита, вычисление и проверка CRC, генерация/проверка PID (идентификатора пакета) и оценка &ldquo;рукопожатия&rdquo;. Интерфейс взаимодействует с приёмопередатчиком USB и использует буферы, предоставляемые Интерфейсом Пакетных буферов (PBI), для хранения данных. Также этот блок генерирует необходимые сигланы, соответствующие событиям USB, такие как Начало фрейма (Start of Frame, SOF), сброс USB, и т.д., и сигналы, относящиеся к событиям Конечных точек, такие как окончание передачи или успешное получение пакета; такие сигналы служат для генерирования прерываний.</li>
<li><strong>Таймер</strong>: Блок генерирует синхронизированный относительно SOF импульс и детектирует глобальную приостановку в случае отсутствия трафика в течение 3 миллисекунд.</li>
<li><strong>Интерфейс Пакетных буферов (Packet Buffer Interface, PBI)</strong>: Блок управляет локальной памятью, реализуя набор буферов как для периёма, так и для передачи. Блок выбирает нужный буфер в соответствии с запросом SIE и находит его в памяти по адресу, указанному в регистрах настройки КТ. Блок увеличивает адрес после каждого принятого или отправленного 16-битного слова, пока не достигнет конца пакета, сохраняя при этом информацию о количестве принятых или переданных байт и защищая буфер от переполнения.</li>
<li><strong>Регистры Конечных точек</strong>: У каждой КТ есть свой регистр, описывающий её тип и текущий статус. Если КТ однонаправленная/с одним буфером, то один регистр может описывать сразу две точки различного направления. Всего регистров — 8, допускающих, таким образом, 16 однонаправленных/однобуферных КТ, либо 7 точек с двумя буферами*, в любых комбинациях. Например, можно запрограммировать 4 КТ с двумя буферами плюс 8 однобуферных.</li>
<li><strong>Управляющие регистры (Control Registers)</strong>: Содержат информацию о статусе USB-периферии в целом и служат для форсирования некоторых событий, таких как возобновление работы (resume) и отключение (power-down).</li>
<li><strong>Регистры настройки прерываний (Interrupt Registers):</strong> Содержат маски прерываний и информацию о событиях. Могут быть использованы для выяснения источника и состояния прерывания, либо для сброса ожидающего прерывания.</li>
</ul>


<p>* <em>— КТ-0, служащая для для управляющей передачи, всегда используется в однобуферном режиме.</em></p>

<p>USB-периферия подключена к шине APB1 через интерфейс APB1, который содержит следующие блоки:</p>

<ul>
<li><strong>Пакетная память</strong>: Локальная память, физически содержащая Пакетные буферы. Может быть использована Интерфейсом Пакетных буферов (PBI) и так же доступна напрямую из пользовательского приложения. Объём Пакетной памяти — 512 байт, представленных как 256 16-битных слов. <em>(На общее пространство памяти каждое такое 16-битное слово отображено в 32-битное слово, с незначащей старшей половиной.)</em></li>
<li><strong>Арбитр</strong>: Блок принимает запросы к памяти как от шины APB1, так и от USB-интерфейса. Он разрешает конфликты в отношении приоритета доступа к APB1, и, в то же время, всегда резервирует половину пропускной способности для того, чтобы завершить все передачи по USB. Эта схема одновременного доступа реализует SRAM с виртуальным двойным портом, что делает возможным доступ к памяти одновременно с происходящей USB-транзакцией. Благодаря такому устройству, возможны многословные APB1-передачи любой длины.</li>
<li><strong>Маппер регистров (Register Mapper)</strong>: Блок собирает побайтные и побитовые регистры USB-периферии в структурированный набор 16-битных слов, доступных по APB1.</li>
<li><strong>APB1-враппер (APB1 Wrapper)</strong>: Блок предоставляет интерфейс к APB1 для памяти и регистра. Он также отображает всю USB-периферию на адресное пространство APB1.</li>
<li><strong>Маппер прерываний (Interrupt Mapper)</strong>: Блок используется для определения того, как именно USB-события будут генерировать прерывания и для их назначения различным линиям NVIC:

<ul>
<li><strong>Низкоприоритетное прерывание (канал 20)</strong>: срабатывает при наступлении любого USB-события (успешная передача, сброс USB, и т.д.). Приложение должно самостоятельно проверять источник прерывания, чтобы правильно его обработать.</li>
<li><strong>Высокоприоритетное прерывание (канал 19)</strong>: срабатывает только после события успешной передачи (transfer) Изохронных или Массивных пакетов с двойной буферизацией для достижения максимальной скорости передачи.</li>
<li><strong>Прерывание пробуждения (канал 42)</strong>: срабатывает по событию пробуждения из режима USB Suspend.</li>
</ul>
</li>
</ul>


<p><a name="prog"></a></p>

<h3>23.4. Соображения по программированию</h3>

<p>Следующие разделы описывают взаимодействие пользовательского приложения с USB-периферией, в целях облегчения разработки ПО.</p>

<p><a name="regular"></a></p>

<h4>23.4.1. Программирование обычного USB-устройства</h4>

<p>Эта часть описывает основные последовательности, необходимые для достижения соответствия ПО стандарту USB. Рассматриваются действия, относящиеся к основным USB-событиям, а также описаны особые случаи: КТ с двойной буферизацией и Изохронный тип передачи. <em>Помимо Системного сброса, действие всегда инициирутся USB-периферией, действующей по одному из описанных ниже событий.</em></p>

<p><a name="reset"></a></p>

<h4>23.4.2. Системный сброс и Сброс при включении МК</h4>

<p>После Системного сброса и Сброса при включении МК, первое, что ПО должно сделать — это настроить необходимые сигналы тактирования USB-периферии и затем снять её сигнал сброса, чтобы получить доступ к регистрам. Необходимая последовательность инициализации описана ниже.</p>

<p><strong>Первым шагом</strong>, ПО должно активировать тактирование макроячейки регистров и снять сигнал сброса макроячейки, используя для этого управляющие биты логики МК.</p>

<p>Аналоговая часть USB-приёмопередатчика, в ключается с помощью бита <code>PDWN</code> в регистре <code>USB_CNTR</code> по определённой схеме. Бит предназначен для вкюлчения источников внутреннего напряжения, питающих приёмопередатчик. Эта цепь имеет некоторую задержку включения (t<sub>STARTUP</sub>, указана в даташите*), в течение которой поведение USB-приёмопередатчика не определено. Таким образом, необходимо подождать указанный интервал после того, как бит <code>PDWN</code> в регистре <code>USB_CNTR</code> будет установлен** (after setting the PDWN bit) и до того, как сбросить блок USB (очисткой бита <code>FRES</code> в регистре <code>USB_CNTR</code>).</p>

<p>Очистка регистра <code>USB_ISTR</code>, впоследствии, сбрасывает все ложные ожидающие прерывания до того того, как будет активирована любая другая операция макроячейки.</p>

<p>После Системного сброса, ПО должно инициализировать все необходимые регистры и таблицу описания Пакетных буферов, чтобы USB-периферия могла правильно генерировать прерывания и передавать данные. Любые регистры, не относящиеся к какой-либо конкретной КТ должны быть инициализированы в соответствии с требованиями ПО (выбранны нужные прерывания, адреса Пакетных буферов и т.д.). После чего настройка продолжается как после Сброса USB (следующий параграф).</p>

<p>* <em>— из даташита: t<sub>STARTUP</sub> — 1 микросекунда; частота тактирования USB —  48 МГц от HSE.</em></p>

<p>** <em>— (Так как бит <code>PDWN</code>, будучи уствновлен в <code>1</code>, отключает аналоговую часть, то логично предположить, что имелась в виду не &ldquo;установка&rdquo; бита, а его сброс. Таким образом, необходимо выждать 1 мкс после сброса бита <code>PDWN</code> и до сброса бита <code>FRES</code>. Изначально оба бита установлены в <code>1</code>.)</em></p>

<p><a name="resusb"></a></p>

<h5>Сброс USB</h5>

<p>После этого события*, USB-периферия находится в том же сотоянии, как после инициализации после Системного сброса, описанного в предыдущем параграфе: приём и передача отключены во всех регистрах КТ (USB-периферия не будет отвечать на посылаемые ей пакеты). После Сброса USB должна быть настроена и активирована USB-Функция с адресом 0, реализованная на КТ-0. Это достигается установкой бита <code>EF</code> (Enable Function) в регистре <code>USB_DADDR</code> и инициализацией регистра <code>USB_EP0R</code> и, соответственно, его Пакетных буферов.</p>

<p>Во время процесса перечисления устройств USB, хост назначит контроллеру его уникальный адрес, который необходимо записать в регистр <code>USB_DADDR</code> в поле <code>ADD[6:0]</code>.</p>

<p>После того, как получено прерывание RESET, ПО ответственно за то, чтобы заново настроить Функцию-0 на КТ-0 в течение 10 мс, отсчитывая от окончания сброса, вызвавшего прерывание.</p>

<p>* <em>— После физического подключения устройства к USB, хост посылает ему сигнал сброса. Периферия реагирует на него сбросом регистров <code>USB_EPnR</code> и <code>USB_DADDR</code>. Передача будет невозможна до очистки флага <code>RESET</code> в регистре <code>USB_ISTR</code>.</em></p>

<p><a name="pbuf"></a></p>

<h5>Структура и использование Пакетных буферов</h5>

<p>Каждая двунаправленная КТ может как получать, так и отправлять данные к хосту. Полученные данные сохраняются в выделенном буфере, зарезервированном для этой точки, в это же время второй буфер содержит данные для отправки. Доступ к памяти буферов осуществляет блок Интерфейса Пакетных буферов (PBI), он доставляет запрос на доступ к памяти и ожидает его подтверждения. Так как память Пакетного буфера в это же время должна быть доступна и микроконтроллеру, то используется арбитраж, разрешающий конфликты доступа, при котором одна половина цикла APB1 отдана в пользу МК, а вторая — USB-периферии. Таким образом, оба устройства могут работать, как если бы пакетная память была двухканальной, не беспокоясь ни о каком конфликте, даже в случае одновременного доступа.</p>

<p>USB-периферия использует отдельный канал тактирования. Частота канала определяется стандартом USB и составляет 48 МГц, в то же время она может быть отличной от выбранной частоты интерфейса APB1. Возможны различные конфигурации тактирования, когда частота APB1 больше, либо меньше частоты USB-периферии.</p>

<p><em>Из-за скорости передачи данных по USB и требований интерфейса пакетной памяти, частота APB1 должна быть больше 8 МГц, чтобы избежать проблем переполнения/опустошения данных.</em></p>

<p>Каждая Конечная точка имеет два Пакетных буфера (обычно один служит для передачи, а другой — для приёма). Буферы могут быть размещены в любой области пакетной памяти, поскольку их расположение и размер указываются в таблице дескрипторов Пакетных буферов, которая так же расположена в пакетной памяти по адресу, указываемому в регистре <code>USB_BTABLE</code>. Каждая запись в таблице связана с одним из регистров КТ и состоит из четырёх 16-битных слов, поэтому адрес начала таблицы должен всегда быть выровнен по 8-байтной границе (младшие три бита регистра <code>USB_BTABLE</code> всегда нули). Формат записей таблицы дескрипторов описан в Разделе 23.5.3. Если КТ однонаправленная и не является ни Изохронной, ни Массивной с двойной буферизацией, то, в таком случае, нужен только один буфер (соответствующий поддерживаемому направлению передачи). Области таблицы, предназначенные для неподдерживаемого направления, либо не используемые другими КТ, могут быть свободно использованы. Изохронные и Массивные КТ с двойной буферизацией взаимодействуют с Пакетными буферами особым образом (смотри Раздел 23.4.4. и Раздел 23.4.3 соответственно). Взаимосвязь таблицы дескрипторов и Пакетных буферов наглядно представлена на рисунке 221.</p>

<p><img src="221.png"></p>

<p>Каждый Пакетный буфер для приёма, либо для передачи, используется начиная с младшего адреса. USB-периферия никогда не будет изменять содержимое памяти по соседству с выделенными буферами; если принимаемый пакет не входит в выделенный для него буфер (произошло переполнение буфера), то будут скопированы лишь те данные, которые в него помещаются.</p>

<p><a name="epinit"></a></p>

<h5>Инициализация Конечной точки</h5>

<p><strong>Первый шаг по инициализации КТ</strong> — записать правильные значения в регистры <code>USB_ADDRn_TX</code> и <code>USB_ADDRn_RX</code>, для того, чтобы сразу обеспечить USB-периферию передаваемыми данными и буфером для принимаемых данных. Поле <code>EP_TYPE</code> в регистре <code>USB_EPnR</code> должно быть установлено в соответствии с типом КТ, по необходимости задействуя бит <code>EP_KIND</code> для обеспечения особых функций. Передача должна быть включена битами <code>STAT_TX</code> в регистре <code>USB_EPnR</code>, кроме того, регистр <code>USB_COUNTn_TX</code> так же должен быть инициализирован. Для приёма должны быть установлены биты <code>STAT_RX</code>, кроме того, в регистре <code>USB_COUNTn_RX</code> должен быть указан размер выделенного буфера при помощи двух полей: <code>BL_SIZE</code> (размер блока) и <code>NUM_BLOCK</code> (количество блоков). Однонаправленные КТ, за исключением Изохронных и Массивных с двойной буферизацией, должны инициализировать только биты, соответствующие поддерживаемому ими направлению передачи. Посе того, как приём или передача будут включены, регистр КТ <code>USB_EPnR</code> и регистры табицы дескрипторов <code>USB_ADDRn_TX</code>, <code>USB_ADDRn_RX</code>, <code>USB_COUNTn_TX</code> и <code>USB_COUNTn_RX</code> не должны изменяться из ПО, так как они могут быть изменены аппаратно во время работы периферии. После окончания передачи, обозначенного генерацией прерывания CTR, регистры снова доступны и могут быть изменены для следующей операции.</p>

<p><a name="in"></a></p>

<h5>Пакеты IN (передача данных)</h5>

<p>Когда получен токен IN, при условии, что запрашиваемый адрес соответствует правильно настроенной КТ, USB-периферия читает содержимое <code>USB_ADDRn_TX</code> и <code>USB_COUNTn_TX</code> для этой КТ, записанное в таблице дескрипторов буферов и записывает значения во внутренние 16-битные регистры ADDR и COUNT (не доступны ПО). Затем пакетная память вновь запрашивается, но уже для чтения первого 16-битного слова, которое необходимо отправить (смотри раздел &ldquo;Структура и использование Пакетных буферов&rdquo; выше) и начинает передачу пакета PID для DATA0 или DATA1, в зависимости от состояния бита <code>DTOG_TX</code> региста <code>USB_EPnR</code>. После передачи пакета PID, из буфера читается первый байт слова, прочитанного ранее из пакетной памяти, и загружается в выходной сдвиговый регистр для отпрвки по шине USB. После отправки последнего байта посылается вычисленная контрольная сумма пакета — CRC.</p>

<p>В случае, когда запрашиваемая хостом КТ недоступна (not valid), вместо данных отправляется &ldquo;рукопожатие&rdquo; NAK, либо STALL, в зависимости от состояния битов <code>STAT_TX</code> регистра <code>USB_EPnR</code>.</p>

<p>Внутренний регистр ADDR используется в качестве указателя на текущую позицию данных в памяти, а COUNT — для подсчёта оставшихся для отправки байтов. Каждое 16-битное слово, прочитанное из памяти Пакетных буферов отправляется по USB-шине начиная с младшего байта. Из памяти буфера для отправки читается COUNTn_TX/2 слов, начиная с адреса, указанного в <code>USB_ADDRn_TX</code>. Если передаваемый пакет данных состоит из нечётного числа байт, то из последнего слова отправляется лишь младшая половина.</p>

<p><strong>При получении подтверждения ACK от хоста</strong>, регистр <code>USB_EPnR</code> обновляется следующим образом: переключается бит <code>DTOG_TX</code>, Конечная точка объявляется временно недоступной, установкой битов <code>STAT_TX</code> в <code>10</code> (<strong>NAK</strong>) и установкой <code>CTR_TX</code>. ПО сперва должно определить КТ, которая требует внимания, используя для этого биты <code>EP_ID</code> и <code>DIR</code> регистра <code>USB_ISTR</code>. Обработка события <code>CTR_TX</code> начинается с очистки бита прерывания; во время обработки ПО должно подготовить новый буфер для отправки, обновить значение в <code>USB_COUNTn_TX</code>, в соответствии с количеством вновь отправляемых данных и, наконец, установить биты <code>STAT_TX</code> в <code>11</code> (VALID) для возобновения передачи. Пока биты <code>STAT_TX</code> равны <code>10</code> (NAK), любой запрос IN, адресованный к этой КТ отвергается отправлением ответа NAK, обозначая состояние управления потоком: хост будет периодически пытаться возобновить транзакцию, до тех пор, пока ему это не удастся. Важно выполнять операции в указанном выше порядке для того, чтобы не потерять очередную IN-транзакцию, адресованную этой же КТ, которая может следовать сразу за первой, вызвавшей прерывание CTR.</p>

<p><a name="out"></a></p>

<h5>Пакеты OUT и SETUP (приём данных)</h5>

<p>Оба этих токена обрабатываются USB-периферией примерно одинаково; отличия обработки SETUP-пакетов описаны в следующем параграфе об управляющих передачах.</p>

<p>При получении PID для OUT/SETUP, если полученный адрес совпадает с настроенной КТ, USB-периферия обращается к <code>USB_ADDRn_RX</code> и <code>USB_COUNTn_RX</code>, соответствующим КТ. Значение <code>USB_ADDRn_RX</code> сохраняется во внутреннем буфере ADDR. В это же время внутренний буфер COUNT сбрасывается, а значения битовых полей <code>BL_SIZE</code> и <code>NUM_BLOCK</code>, прочтённые из регистра <code>USB_COUNTn_RX</code>, используются для инициализации BUF_COUNT — внутреннего 16-битного счётчика, используемого для определения состояния переполнения. (Ни один из внутренних регистров не доступен ПО.) Байты данных, последовательно получаемые USB-периферией, упаковываются в 16-битные слова (первый байт записывается в младшую половину) и затем отправляются в Пакетный буфер по адресу, записанному во внутреннем регистре ADDR, в это же время счётчик BUF_COUNT уменьшается, а COUNT увеличивается на количество принятых байтов. После приёма пакета, обозначающего конец данных, проверяется корректность принятой контрольной суммы CRC и, если не случилось ошибок передачи, в ответ хосту отправляется пакет-&ldquo;рукопожатие&rdquo; ACK.</p>

<p>В случае неправильной контрольной суммы CRC, либо других ошибок (отсутствие дополнительного бита, ошибки фрейма и т.д.), данные всё равно будут скопированы в Пакетный буфер, как минимум до момента возникновения ошибки, однако, в этом случае пакет ACK не будет отправлен хосту, а будет установлен бит <code>ERR</code> в регистре <code>USB_ISTR</code>. В любом случае, от ПО не требуется каких-то дополнительных действий: USB-периферия сама восстанавливается от ошибок приёма и всегда готова к следующей транзакции. Если КТ в настоящий момент недоступна, то хосту, вместо ACK отправляется пакет-&ldquo;рукопожатие&rdquo; NAK, либо STALL, в зависимости от состояния битов <code>STAT_RX</code> регистра <code>USB_EPnR</code>, и в память Пакетных буферов ничего не будет записано.</p>

<p>Память Пакетного буфера для приёма заполняется, начиная с адреса, записанного в <code>USB_ADDRn_RX</code>, для всех байтов принимаемого пакета, включая CRC (т.е. размер полезных данных + 2 байта), либо до последнего возможного адреса буфера, определяемого полями <code>BL_SIZE</code> и <code>NUM_BLOCK</code>, в зависимости от того, что случится вперёд. Таким образом, USB-периферия никогда не будет писать за пределы отведённого ей буфера. Если длина получаемого пакета с полезными данными (байты, непосредственно используемые ПО) превышает размер буфера, то возникает состояние переполнения. В таком случае в ответ хосту, вместо обычного ACK, отправляется &ldquo;рукопожатие&rdquo; STALL, чтобы уведомить его о проблеме, прерывание не генерируется, а транзакция считается неудачной.</p>

<p><strong>Когда транзакция завершается корректно</strong>, посылкой пакета ACK, внутренний регистр-счётчик COUNT копируется обратно в <code>USB_COUNTn_RX</code>, находящийся в таблице дескрипторов буферов, не изменяя состояение полей <code>BL_SIZE</code> и <code>NUM_BLOCK</code>, которые не нуждаются в изменении, а регистр <code>USB_EPnR</code> изменяется следующим образом: бит <code>DTOG_RX</code> переключается, КТ временно объявляется недоступной, установкой битов <code>STAT_RX</code> в <code>10</code> (<strong>NAK</strong>), и устанавливается бит <code>CTR_RX</code>. Если же транзакция была неудачной, то ничего из перечисленного не происходит.</p>

<p>Первым делом ПО определяет КТ, к которой поступил запрос, читая биты <code>EP_ID</code> и <code>DIR</code> регистра <code>USB_ISTR</code>. Обработка события <code>CTR_RX</code> начинается с определения типа транзакции (бит <code>SETUP</code> регистра <code>USB_EPnR</code>); ПО сбрасывает флаг прерывания и узнаёт сколько данных было принято, читая регистр <code>USB_COUNTn_RX</code>, находящийся в таблице дескрипторов буферов. После того, как данные были обработаны, ПО должно само установить биты <code>STAT_RX</code> регистра <code>USB_EPnR</code> в состояние <code>11</code> (VALID), разрешая тем самым следующую транзакцию. Пока биты <code>STAT_RX</code> находятся в состоянии <code>10</code> (NAK), любые запросы типа OUT, адресованные этой КТ отвергаются пакетом-&ldquo;рукопожатием&rdquo; NAK, обозначая таким образом состояние управления потоком: хост будет периодически пытаться возобновить транзакцию, до тех пор, пока ему это не удастся. Важно выполнять операции в указанном выше порядке, для того, чтобы не потерять очередную OUT-транзакцию, адресованную этой же КТ, которая может следовать сразу за первой, вызвавшей прерывание.</p>

<p><a name="ctl"></a></p>

<h5>Управляющие (Control) передачи</h5>

<p>Управляющие передачи выполняются постредством SETUP-транзакции, после которой могут следовать стадии передачи данных в этом же направлении и завершаются передачей статуса (ноль-байтная передача в обратном направлении).</p>

<p><strong>SETUP-транзакции обрабатываются</strong> только управляющими КТ, по очень схожему с обработкой OUT-транзакций (приём данных) сценарию, за ислючением того, что биты <code>DTOG_TX</code> и <code>DTOG_RX</code> запрашиваемой КТ устанавливаются в значения <code>1</code> и <code>0</code> соответственно, чтобы инициализировать управляющую передачу, а так же оба поля <code>STAT_TX</code> и <code>STAT_RX</code> устанавливаются в значение <code>10</code> (NAK) для того, чтобы ПО само могло решить каким будет направление следующей транзакции — IN, либо OUT — в зависимости от содержания SETUP-пакета.</p>

<p>Управляющая КТ должна проверять состояние бита <code>SETUP</code> в регистре <code>USB_EPnR</code> каждый раз, при возникновении события <code>CTR_RX</code>, чтобы отличать обычные OUT-транзакции от SETUP-транзакций. USB устройство может определить количество и направление стадий передачи данных, интерпретируя сами данные во время SETUP-стадии, и обязано остановить (STALL) транзакцию в случае обнаружения ошибок. Для этого, на всех стадиях передачи данных, кроме последней, неиспользуемое направление должно быть объявлено STALL, чтобы хост, если вдруг он поменяет направление передачи раньше, чем это нужно, поучил STALL при выяснении статуса.</p>

<p>Во время включения последней стадии передачи данных, противоположное направление должно быть установлено в NAK, для того, чтобы хост, если вдруг он незамедлительно поменяет направление передачи (для проведения стадии выяснения статуса), продолжил ожидание завершения управляющей операции. Если управляющая операция завершилась успешно, ПО меняет NAK на VALID, либо, в случае неудачи, на STALL.</p>

<p>В это же время, если направление стадии выяснения статуса — OUT, бит <code>STATUS_OUT</code> (<code>EP_KIND</code> регистра <code>USB_EPnR</code>) должен быть установлен в <code>1</code> для того, чтобы была сгенерирована соответствующая ошибка, в случае, если статусная транзакция осуществляется с ненулевыми данными. После того, как статусная транзакция будет  обработана, ПО очищает бит <code>STATUS_OUT</code> и устанавливает поле <code>STAT_RX</code> в состояние VALID (чтобы принять новую команду), а поле <code>STAT_TX</code> — в состояние NAK (чтобы задержать стадию выяснения статуса, которая может следовать непосредственно за следующим SETUP-пакетом).</p>

<p>Ввиду того, что стандарт USB не позволяет отвечать на SETUP-пакет никаким другим &ldquo;ркуопожатием&rdquo;, кроме как ACK, внезапно прервав текущую команду и начав новую, логика USB-периферии не позволит ответить хосту пакетами NAK, либо STALL на его SETUP-запрос.</p>

<p>Если биты <code>STAT_RX</code> установлены в <code>01</code> (STALL), либо в <code>10</code> (NAK) и в это же время принимается SETUP-пакет, то USB-периферия в любом случае примет данные и отправит обратно ACK-&ldquo;рукопожатие&rdquo;. Если предыдущее прерывание <code>CTR_RX</code> этой КТ не было обработано приложением (например, бит <code>CTR_RX</code> всё ещё установлен, с предыдущего приёма), USB-периферия отбрасывает SETUP-транзакцию и никак на неё не отвечает, независимо от её состояния, симулируя, тем самым, ошибку приёма и вынуждая хост отправить SETUP-токен ещё раз. Это сделано для того, чтобы избежать потерю SETUP-транзакции, отправленной одной и той же КТ непосредственно за транзакцией, вызвавшей прерывание <code>CTR_RX</code>.</p>

<p><a name="dblbuf"></a></p>

<h4>23.4.3. Конечные точки с двойной буферизацией</h4>

<p>Различные типы КТ, определённые в стандарте USB, представляют различные модели передачи данных и предъявляют разные требования к операциям передачи данных. Если между хостом и USB-устройством необходимо передавать большие объёмы данных, то в этом случае лучше подойдёт Массивный (Bulk) тип КТ. Так как хост в этом случае планирует транзакции таким образом, чтобы использовать всю возможную пропускную способность фрейма, максимизируя, тем самым, скорость передачи данных, если USB-устройство готово работать с отправляемыми ему Массивными транзакциями. Если устройство будет занято обработкой предыдущей транзакции, в то время, как поступит следующая, оно должно ответить NAK-&ldquo;рукопожатием&rdquo;, в результате чего хост будет отправлять последнюю транзакцию повторно, до тех пор, пока устройство не будет готово её обработать, что снижает фактическую скорость передачи, так как повторные посылки отнимают часть пропускной способности. По этой причине, для Массивных КТ может быть использована так называемая двойная буферизация.</p>

<p>Когда двойная буферизация включена, происходит последовательное переключение активного буфера после каждой удачной транзакции, задействуя при этом, в качестве переключаемого буфера, обе области пакетной памяти — &ldquo;принимающую&rdquo; и &ldquo;передающую&rdquo;, с целью, чтобы целый буфер был доступен каждый раз одновременно и приложению и USB-периферии. Например, во время OUT-транзакции в направлении принимающей Массивной КТ с двойной буферизацией, один из буферов заполняется данными, принимаемыми от хоста и, в это же время, другой доступен приложению МК (также будет и в случае с отправкой данных по IN-транзакции Массивной КТ с двойной буферизацией).</p>

<p>Так как переключаемый буфер должен использовать все четыре записи в таблице дескрипторов буферов, то регистры, <code>USB_EPnR</code> реализующие Массивные КТ с двойной буферизацией (МКТДБ), вынуждены быть однонаправленными. Таким образом, только одно поле <code>STAT</code> должно быть установлено в значение, отличное от <code>00</code> (выключено): <code>STAT_RX</code>, в случае, когда МКТДБ принимает данные и <code>STAT_TX</code> — когда отправляет. Если есть необходимость использовать МКТДБ для приёма и передачи одновременно, то должна быть использована пара регистров <code>USB_EPnR</code>.</p>

<p><strong>При использовании двойной буферизации</strong> для достижения максимальной скорости передачи, порядок обработки событий КТ, описанный в предыдущих разделах, должен быть изменён таким обраом, чтобы переключать статус КТ в NAK только при конфликте доступа к буферу, возникающем между ПО и USB-периферией, вместо того, чтобы делать это после каждой успешной транзакции.</p>

<p>Буфер, в настоящее время используемый USB-периферией, определяется по состоянию бита <code>DTOG</code> регистра <code>USB_EPnR</code>, соответствующего направлению КТ: <code>DTOG_RX</code> — для принимающей МКТДБ и <code>DTOG_TX</code> — для передающей. Для взаимодействия USB-периферия должна знать какой из буферов приложение использует в данный момент, чтобы избежать конфликта. Так как в регистре <code>USB_EPnR</code> два варианта бита <code>DTOG</code> и только один из них используется USB-периферией для перекючения буферов, то другой может быть использован приложением, чтобы показать, каким буфером оно пользуется в данный момент — новый флаг носит название <code>SW_BUF</code>. В таблице ниже представлено соответствие между битами регистра <code>USB_EPnR</code> и битами <code>DTOG</code>/<code>SW_BUF</code>, для обоих случаев — принимающих и передающих МКТДБ.</p>

<p><img src="tab_169.png"></p>

<p>Буфер, изпользуемый в данный момент USB-периферией, определяется по биту <code>DTOG</code>, в то время как буфер, используемый приложением — по флагу <code>SW_BUF</code>. Взаимосвязь между значением флага и используемым буфером одинаковая в обоих случаях, она показана в следующей таблице.</p>

<p><img src="tab_170.png"></p>

<p><em>1 — КТ находится в состоянии NAK.</em></p>

<p><strong>Функция двойной буеризации включается по:</strong></p>

<ul>
<li>записи <code>00</code> в поле <code>EP_TYPE</code> регистра <code>USB_EPnR</code>, что определяет тип КТ как &ldquo;Массивная&rdquo; (Bulk),</li>
<li>и по установке бита <code>EP_KIND</code>  в <code>1</code> (DBL_BUF) в том же регистре.</li>
</ul>


<p>ПО ответственно за инициаизацию битов <code>DTOG</code> и <code>SW_BUF</code>, в зависимости от первого используемого буфера; это должно быть сделано с учётом такого свойства этих битов, что они могут только переключаться (toggle). Окончание первой транзакции, произошедшей после установки бита <code>DBL_BUF</code> (он же <code>EP_KIND</code>), активирует режим двойной буеризации, который будет использован для всех последующих транзакций до тех пор, пока бит будет установлен. В конце каждой транзакции будет установлен бит <code>CTR_RX</code> или <code>CTR_TX</code> в регистре <code>USB_EPnR</code> запрашиваемой КТ, в зависимости от выбранного направления. В это же время, зависимый бит <code>DTOG</code> в регистре <code>USB_EPnR</code> переключается аппаратно, делая переключение буферов USB-периферии полностью независимым от ПО. В отличие от обычных транзакций и первой, которая произошла после установки бита <code>DBL_BUF</code>, поле STAT не изменяется после окончания транзакции и остаётся всегда равным <code>11</code> (VALID). Однако, как только получен пакет-токен новой транзакции, то, при возникновении конфикта доступа к буферу между USB-периферией и ПО, фактический статус КТ будет маскирован и будет иметь значение <code>10</code> (NAK) (такую ситуацию можно определить по битам <code>DTOG</code> и <code>SW_BUF</code>, которые в этом случае будут иметь одно значечние).</p>

<p><strong>ПО отвечает на событие CTR</strong> сбросом флага прерывания и началом требующейся обработки совершённой транзакции. Как только ПО закончит использовать свой Пакетный буфер, оно должно переключить бит <code>SW_BUF</code>, записав в него <code>1</code>, для того, чтобы уведомить USB-периферию о доступности той своего буфера. <em>Таким образом, количество отвергнутых (NAK) запросов хоста определяется только временем обработки приложением данных транзакции: если вермя обработки меньше, чем требуется для завершения транзакции, то повторной посылки происходить не будет и общая скорость передачи будет ограничена только лишь хостом.</em></p>

<p>Приложение всегда может переопределить поведение МКТДБ, принудительно записав статус, отличный от <code>11</code> в поле <code>STAT</code> соответствующего регистра <code>USB_EPnR</code>. В этом случае USB-периферия будет использовать назначенный статус, вне зависимости от того как используются буферы.</p>

<p><a name="iso"></a></p>

<h4>23.4.4. Изохронные (Isochronous) передачи</h4>

<p>USB стандарт поддерживает полноскоростные устройства, требующие фиксированной и точной частоты передачи данных и определяет такие устройства как &ldquo;Изохронные&rdquo;. Типичные примеры таких данных: потоки аудио, видео и, по большому счёту, любые семплируемые с фиксированной частотой данные, требующие точного времени доставки. Если во время перечисления Конечная точка определяется как Изохронная, то хост резервирует для неё во фрейме необходимую пропускную способность и для каждого фрейма доставляет один единственный пакет IN, либо OUT, в зависимости от направления КТ.</p>

<p>Чтобы ограничить требования по пропускной способности, для Изохронного потока убрана возможность повторной транзакции в случае ошибки; из этого следует то, что для Изохронной транзакции отсутствует фаза &ldquo;рукопожатия&rdquo; и стороны не ожидают отправки ACK-пакета после отправки данных. Для той же цели, Изохронные передачи не поддерживают переключение типов пакетов DATA0/DATA1 и данные всегда передаются в пакете типа DATA0.</p>

<p><strong>Изохронное поведение КТ выбирается</strong> установкой поля <code>EP_TYPE</code> в регистре <code>USB_EPnR</code> в значение <code>10</code>; а ввиду того, что отсутствует фаза &ldquo;рукопожатия&rdquo;, существует всего два возможных значения полей <code>STAT_RX</code> и <code>STAT_TX</code> — это <code>00</code> (DISABLED) и <code>11</code> (VALID), любое другое значение приведёт к несовместимости со стандартом USB.</p>

<p>Изохронные КТ используют только двойную буферизацию, задействуя при этом для переключения после каждой транзакции обе области пакетной памяти, &ldquo;принимающую&rdquo; и &ldquo;передающую&rdquo;, с целью, чтобы весь буфер был доступен каждый раз одновременно и приложению и USB-периферии.
Текущий буфер, используемый в данный момент USB-периферией, определяется битом  <code>DTOG</code> соответствующего направления КТ (<code>DTOG_RX</code> — для принимающих Изохронных КТ и <code>DTOG_TX</code> —  для передающих) в регистре <code>USB_EPnR</code>, в соответствии с Табицей 171 (ниже).</p>

<p><img src="tab_171.png"></p>

<p>Точно так же, как и в случае с МКТДБ, ргистры <code>USB_EPnR</code>, используемые для реализации Изохронных КТ, вынуждены быть однонаправленными. Если нужна Изохронная КТ, умеющая как получать, так и передавать данные, то в этом случае должны быть использованы два регистра  <code>USB_EPnR</code>.</p>

<p>За инициализацию бита <code>DTOG</code>, в зависимости от того, какой буфер используется первым, отвечает приложение; это должно быть сделано с учётом такого свойства этих двух битов, что они могут только переключаться (toggle). В конце каждой транзакции будет установлен бит <code>CTR_RX</code> или <code>CTR_TX</code> в регистре <code>USB_EPnR</code> запрашиваемой КТ, в зависимости от выбранного направления. В это же время, зависимый бит <code>DTOG</code> в регистре <code>USB_EPnR</code> переключается аппаратно, делая переключение буферов USB-периферии полностью независимым от ПО. Поле STAT не меняется после окончания транзакции; ввиду того, что Изохронный тип передачи не поддерживает фазу &ldquo;рукопожатия&rdquo;, Конечная точка остаётся всегда <code>11</code> (VALID). Несовпадение CRC и переполнение буфера, возникающие во время Изохронных OUT-передач не считаются ошибками и в любом случае транзакции интерпретируются как корректные и всегда активируют событие <code>CTR_RX</code>. Однако, бит <code>ERR</code> в регистре <code>USB_ISTR</code> всё же будет установлен в случае ошибки CRC, чтобы приложение могло определить возможную порчу данных.</p>

<p><a name="susp"></a></p>

<h4>23.4.5. События Приостановки/Возобновления (Suspend/Resume)</h4>

<p>Стандарт USB определяет особое сотояние периферийного устройства, называемое &ldquo;Приостановкой&rdquo; (SUSPEND), в котором среднее потребление тока от шины USB не должно превышать 2.5 мА. Это требование крайне важно для устройств, питающихся от шины USB, в то время как для устройств с внешним питанием не требуется его чёткого соблюдения.</p>

<p>В режиме Приостановки хост посылает уведомление о недопустимости генерировать какой-либо трафик по USB-шине в течение 3 миллисекунд: поскольку в обычном режиме пекет Начала фрейма (Start of Frame, SOF) шлётся каждую миллисекунду, то отсутствие трёх SOF-пакетов подряд USB-периферия распознаёт как запрос от хоста на Приостановку и устанавливает бит <code>SUSP</code> в регистре <code>USB_ISTR</code> в <code>1</code>, генерируя, тем самым, соответствующее прерывание, если оно включено. Приостановленное устройство может возобновить работу при помощи так называемой RESUME-последовательноси, которую может инициировать хост, либо само устройство непосредственно, но завершает последовательность всегда именно хост.</p>

<p>Приостановленное устройство должно уметь детектировать RESET-последовательность, реагируя на неё, как на обычный Сброс USB.</p>

<p><strong>Конкретная процедура приостановки</strong> USB-периферии зависит от самого устройства, поэтому для снижения потребления тока могут понадобиться различные действия. Краткое описание обычной процедуры приостановки, акцентирующее внимание на аспектах ПО, отвечающего на SUSPEND-уведомление, в отношении USB, приведено ниже:</p>

<ol>
<li>Установите бит <code>FSUSP</code>  в регистре <code>USB_CNTR</code> в <code>1</code>. Это включит режим Приостановки USB-периферии. Как только режим будет включен, проверка на приём SOF-пакета отключается, чтобы избежать повторной генерации прерывания во время действия Приостановки.</li>
<li>Отключите, либо сократите потребление энергии другими блоками, отличными от USB-периферии.</li>
<li>Установите бит <code>LP_MODE</code> в регистре <code>USB_CNTR</code> в <code>1</code>, чтобы снизить потребление тока USB-трансивером, но оставить возможность детектирования сигналов о Возобновлении.</li>
<li>Дополнительно можно отключить внешний генератор (external oscillator) и PLL, для остановки любой активности внутри устройства.</li>
</ol>


<p>Если во время Приостановки возникает какое-то USB-событие, то для восстановления режима тактирования и возвращения к обычному поведению должна быть выполнена RESUME-процедура. Особое внимание должно быть уделено тому, чтобы этот процесс не занял больше 10 миллисекунд в случае, когда событием восстановления является Сброс USB (смотрите спецификацию USB для уточнения деталей).</p>

<p><strong>Возобновление или Сброс USB-периферии</strong>, находящейся в состоянии Приостановки, начинается с асинхронного сброса бита <code>LP_MODE</code>  в регистре <code>USB_CNTR</code>.</p>

<p><em>Несмотря на то, что событие может сгенерировать прерывание WKUP, если оно активно, использовать такое прерывание нужно с осторожностью ввиду большой задержки при перезапуске системного источника тактирования; советуем расположить процедуру Возобновления сразу после процедуры Приостановки, чтобы МК незамедлительно начал выполнение кода с нужного места, как только произойдёт перезапуск системного источника тактирования.</em></p>

<p><em>Чтобы предотвратить Возобновление системы от случайного статического разряда, либо от других типов помех (выход из Приостановки — асинхронное событие), во время Приостановки активируется соответствующий аналоговый фильтр состояния линии данных; временное разрешение фильтра (filter width) — 70 наносекунд.</em></p>

<p>Ниже приведена последовательность действий, которую надо выполнить в процедуре Возобновления:</p>

<ol>
<li>Включите внешний генератор (external oscillator) и/или PLL, если нужно.</li>
<li>Очистите бит <code>FSUSP</code> в регистре <code>USB_CNTR</code>.</li>
<li>Если есть необходимость определить источник события Возобновления, то могут быть использованы биты <code>RXDP</code> и <code>RXDM</code> в регистре <code>USB_FNR</code>, значение которых указано в Таблице 172 ниже, в ней же приводится и список действий, которые следует выполнить приложению для каждого из случаев. По необходимости, окончание последовательности Возобновления или Сброса может быть так же определено, по состоянию <code>10</code> указанных битов, которое говорит о том, что шина не занята; кроме того, по окончании последовательности Сброса, бит <code>RESET</code> в регистре <code>USB_ISTR</code> будет установлен в <code>1</code>, что сгенерирует соответствующее прерывание, если оно активно, которое должно быть обработано.</li>
</ol>


<p><img src="tab_172.png"></p>

<p>Иногда устройству бывает необходимо выйти из режима Приостановки, чтобы ответить на событие, не относящееся к протоколу USB <em>(как, например, движение мышкой пробуждает всю систему целиком)</em>. В этом случае последовательность Возобновления может быть начата с установки бита <code>RESUME</code> в регистре <code>USB_CNTR</code>  в <code>1</code> и его сбросом обратно в <code>0</code> после интервала в 1—15 миллисекуд (интервал может быть измерен по прерываниям ESOF, генерируемым каждую миллисекунду, если системный источник тактирования работает на номинальной частоте). Как только бит <code>RESUME</code> будет вновь очищен, хост самостоятельно завершит необходимую последовательность Возобновления, а её окончание может также быть определено по битам <code>RXDP</code> и <code>RXDM</code> регистра <code>USB_FNR</code>.</p>

<p><em>В любом случае, бит <code>RESUME</code> должен быть использован только после того, как USB-периферия была переведена в режим Приостановки при помощи установки бита <code>FSUSP</code> в регистре <code>USB_CNTR</code> в <code>1</code>.</em></p>

<p><a name="regs"></a></p>

<h3>23.5. Регистры USB</h3>

<p>Регистры USB-периферии могут быть поделены на следующие три группы:</p>

<ul>
<li><strong>Общие регистры</strong>: регистры управления и прерываний.</li>
<li><strong>Регистры Конечных точек</strong>: конфигурация и статус КТ.</li>
<li><strong>Таблица дескрипторов буферов</strong>: расположение буферов в пакетной памяти.</li>
</ul>


<p>Адреса всех регистров записаны как смещение относительно базового адреса USB-периферии — <code>0x40005c000</code>, за исключением таблицы дескрипторов буферов, которая располагается в пакетной памяти по локальному адресу, указываемому в регистре <code>USB_BTABLE</code>.</p>

<p>Ввиду ограничений моста APB1 относительно возможностей адресации, адреса всех регистров выровнены по 32-битной границе слова, но сами регистры 16-битные. Такое же выравнивание адресов используется при доступе к Пакетным буферам, память которых начинается с <code>0x40006000</code>.</p>

<p>Регистры могут быть доступны как по полслова (16 бит), так и по целому слову (32 бита).</p>

<p><em>Сокращения, ипользованные при описании регистров приведены в Разделе 2.2, на странице 45.</em></p>

<p><a name="common"></a></p>

<h4>23.5.1. Общие регистры</h4>

<p>Эти регистры влияют на поведение USB-периферии в целом, определяя её режим, обработку прерываний, USB-адрес устройства и позволяют узнать номер текущего фрейма, который обновляется хостом.</p>

<p><a name="USB_CNTR"></a></p>

<h5>Управляющий регистр USB (control, <code>USB_CNTR</code>)</h5>

<pre><code>Смещение адреса:        0x40
Значение после сброса:  0x0003
</code></pre>

<p><img src="reg_CNTR.png"></p>

<ul>
<li>15: <br> <code>CTRM</code> <br>
<strong>Маска прерывания успешной передачи CTR</strong> (correct transfer)

<ul>
<li><strong>0</strong>: Прерывание CTR отключено.</li>
<li><strong>1</strong>: Прерывание CTR включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>14: <br> <code>PMAOVRM</code> <br>
<strong>Маска прерывания переполнения/опустошения буфера</strong> (packet memory area over/underrun)

<ul>
<li><strong>0</strong>: Прерывание PMAOVR отключено.</li>
<li><strong>1</strong>: Прерывание PMAOVR включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>13: <br> <code>ERRM</code> <br>
<strong>Маска прерывания ошибки</strong> (error)

<ul>
<li><strong>0</strong>: Прерывание ERR отключено.</li>
<li><strong>1</strong>: Прерывание ERR включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>12: <br> <code>WKUPM</code> <br>
<strong>Маска прерывания Возобновления</strong> (wakeup)

<ul>
<li><strong>0</strong>: Прерывание WKUP отключено.</li>
<li><strong>1</strong>: Прерывание WKUP включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>11: <br> <code>SUSPM</code> <br>
<strong>Маска прерывания Приостановки</strong> (suspend)

<ul>
<li><strong>0</strong>: Прерывание SUSP отключено.</li>
<li><strong>1</strong>: Прерывание SUSP включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>10: <br> <code>RESETM</code> <br>
<strong>Маска прерывания Сброса USB</strong> (USB reset)

<ul>
<li><strong>0</strong>: Прерывание RESET отключено.</li>
<li><strong>1</strong>: Прерывание RESET включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>9: <br> <code>SOFM</code> <br>
<strong>Маска прерывания Начала фрейма (SOF)</strong> (start of frame)

<ul>
<li><strong>0</strong>: Прерывание SOF отключено.</li>
<li><strong>1</strong>: Прерывание SOF включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>8: <br> <code>ESOFM</code> <br>
<strong>Маска прерывания ожидавшегося Начала фрейма</strong> (expected start of frame)

<ul>
<li><strong>0</strong>: Прерывание ESOF отключено.</li>
<li><strong>1</strong>: Прерывание ESOF включено. Прерывание генерируется, если в регистре USB_ISTR установлен соответствующий бит.</li>
</ul>
</li>
<li>4: <br> <code>RESUME</code> <br>
<strong>Запрос на Возобновление</strong> (resume request)

<ul>
<li>ПО может установить этот бит, чтобы отправить RESUME-сигнал хосту. Он должен быть активирован на не менее, чем 1 мс и не более, чем 15 мс, после чего хост будет готов провести последовательность Возобновления до конца.</li>
</ul>
</li>
<li>3: <br> <code>FSUSP</code> <br>
<strong>Принудительная Приостановка</strong> (force suspend)

<ul>
<li>Приложение должно установить этот бит, как только получено прерывание SUSP, которое генерируется, если трафик на линии отсутствует в течение 3 мс.</li>
<li><strong>0</strong>: -</li>
<li><strong>1</strong>: Перейти в режим Приостановки. Энергопотребление и тактировани трансивера остаётся прежним. Для снижения энергопотребления ПО должно включить бит LP_MODE после FSUSP.</li>
</ul>
</li>
<li>2: <br> <code>LP_MODE</code> <br>
<strong>Режим низкого энергопортебления</strong> (low-power mode)

<ul>
<li>Включает пониженное потребление для режима Приостановки. Бит сбрасывается автоматически, при активности на линии.</li>
<li><strong>0</strong>: Нормальное энергопотребление.</li>
<li><strong>1</strong>: Пониженное энергопотребление.</li>
</ul>
</li>
<li>1: <br> <code>PDWN</code> <br>
<strong>Выключение</strong> (power down)

<ul>
<li>Полностью отключает аналоговую часть USB.</li>
<li><strong>0</strong>: Включает аналоговую часть.</li>
<li><strong>1</strong>: Отключает аналоговую часть.</li>
</ul>
</li>
<li>0: <br> <code>FRES</code> <br>
<strong>Принудительный Сброс USB</strong> (force USB reset)

<ul>
<li><strong>0</strong>: Убирает Сброс USB.</li>
<li><strong>1</strong>: Вызывает принудительный Сброс USB-периферии. Очищается приложением. Генерирует прерывание RESET, если оно активно.</li>
</ul>
</li>
</ul>


<p><a name="USB_ISTR"></a></p>

<h5>Регистр состояния прерываний USB (interrupt status, <code>USB_ISTR</code>)</h5>

<pre><code>Смещение адреса:        0x44
Значение после сброса:  0x0000
</code></pre>

<p><img src="reg_ISTR.png"></p>

<p>Регистр содержит информацию обо всех источниках прерываний, давая возможность приложению определить какое именно событие вызвало прерывание.</p>

<p>Приложение ответственно за очистку флагов прерываний. Флаги очищаются записью в них нуля.</p>

<ul>
<li>15: <br> <code>CTR</code> <br>
<strong>Успешная передача</strong> (correct transfer)

<ul>
<li>Устанавливается и очищается аппаратно. Обозначает успешное окончание транзакции.</li>
</ul>
</li>
<li>14: <br> <code>PMAOVR</code> <br>
<strong>Переполнение/опустошение буфера</strong> (packet memory area over/underrun)

<ul>
<li>Бит устанавливается, если МК не успел ответить на запрос памяти.</li>
</ul>
</li>
<li>13: <br> <code>ERR</code> <br>
<strong>Ошибка</strong> (error)

<ul>
<li>Бит устанавливается в следующих случаях: NANS — хост не отвечает; CRC — несовпадение контрольной суммы; BST — ошибка вставки дополнительного бита; FVIO — нарушение формата фрейма. USB-периферия сама восстанавливается от подобного рода ошибок.</li>
</ul>
</li>
<li>12: <br> <code>WKUP</code> <br>
<strong>Возобновление</strong> (wakeup)

<ul>
<li>Устанавливается в 1, если во время Приостановки наблюдается активность на линии. Это обытие очищает бит LP_MODE в регистре USB_CNTR.</li>
</ul>
</li>
<li>11: <br> <code>SUSP</code> <br>
<strong>Приостановка</strong> (suspend mode request)

<ul>
<li>Устанавливается в 1, если на линии в течение 3 мс отсутствует какой-либо трафик, что обозначает запрос Приостановки от хоста.</li>
</ul>
</li>
<li>10: <br> <code>RESET</code> <br>
<strong>Сброс USB</strong> (USB reset request)

<ul>
<li>Устанавливается в 1, если USB-периферия обнаруживает USB-запрос на сброс. USB-периферия сбрасывает своё внутреннее состояние, регистры USB_EPnR и USB_DADDR и генерирует прерывание, если установлен бит RESETM в регистре USB_CNTR. Регистры конфигурации USB-периферии не сбрасываются. Приём и передача отключены до тех пор, пока бит не будет сброшен. Установка бита FRES в регистре USB_CNTR устанавливает бит RESET.</li>
</ul>
</li>
<li>9: <br> <code>SOF</code> <br>
<strong>Начало фрейма</strong> (start of frame)

<ul>
<li>Указывает на то, что начался новый фрейм. Бит может быть использован для 1-миллисекундной синхронизации.</li>
</ul>
</li>
<li>8: <br> <code>ESOF</code> <br>
<strong>Ожидалось начало фрейма</strong> (expected start of frame)

<ul>
<li>Устанавливается аппаратно в случае, если ожидавшийся SOF-пакет не был получен.</li>
</ul>
</li>
<li>4: <br> <code>DIR</code> <br>
<strong>Направление передачи</strong> (direction of transaction)

<ul>
<li>Изменяется аппаратно. Обозначает направление передачи.</li>
<li><strong>0</strong>: IN-транзакция. Установлен бит CTR_TX в регистре USB_EPnR.</li>
<li><strong>1</strong>: OUT-транзакция. Установлен бит CTR_RX в регистре USB_EPnR. Либо установлены оба бита — CTR_TX и CTR_RX, в случае двух разных типов транзакций.</li>
</ul>
</li>
<li>[3-0]: <br> <code>EP_ID</code> <br>
<strong>Идентификатор Конечной точки</strong> (endpoint identifier)

<ul>
<li>Изменяется аппаратно. Содержит номер КТ, сгенерировавшей прерывание. Если одновременно несколько КТ генерируют прерывание, то записывается номер КТ с наивысшим приоритетом обслуживания: у Изохронных КТ и МКТДБ приоритет выше, чем у обычных. Если же прерывание сгенерировани несколько КТ с одинаковым приоритетом, то в поле записывается КТ с меньшим номером: КТ-0 будет иметь наивысший приоритет.</li>
</ul>
</li>
</ul>


<p><a name="USB_FNR"></a></p>

<h5>Регистр номера фрейма USB (frame number, <code>USB_FNR</code>)</h5>

<pre><code>Смещение адреса:        0x48
Значение после сброса:  0x0XXX (X - значение не определено)
</code></pre>

<p><img src="reg_FNR.png"></p>

<ul>
<li>15: <br> <code>RXDP</code> <br>
<strong>Состояние линии DP+ при приёме</strong> (receive data+ line status)

<ul>
<li>Бит может быть использован для выяснения статуса линии в конце процедуры Приостановки, для выяснения причины пробуждения.</li>
</ul>
</li>
<li>14: <br> <code>RXDM</code> <br>
<strong>Состояние линии DM- при приёме</strong> (receive data- line status)

<ul>
<li>Бит может быть использован для выяснения статуса линии в конце процедуры Приостановки, для выяснения причины пробуждения.</li>
</ul>
</li>
<li>13: <br> <code>LCK</code> <br>
<strong>Заблокирован</strong> (locked)

<ul>
<li>Устанавливается аппаратно после того, как будут приняты по меньшей мере два SOF-пакета по окончании Сброса USB или последовательности Возобновления. Фрейм-таймер остаётся заблокированным до следующего сброса или Приостановки.</li>
</ul>
</li>
<li>12-11: <br> <code>LSOF</code> <br>
<strong>Потерянный SOF</strong> (lost SOF)

<ul>
<li>Устанавливается аппаратно во время генерации ESOF-прерывания и обозначает число потерянных фреймов. Если в дальнейшем пакет всё же поступит, то поле очищается.</li>
</ul>
</li>
<li>10-0: <br> <code>FN</code> <br>
<strong>Номер фрейма</strong> (frame number)

<ul>
<li>Содержит номер фрейма из последнего принятого SOF-пакета. Номер увеличивается с каждым новым фреймом. Значение может быть полезно для Изохронных передач. Поле обновляется во время генерации SOF-прерывания.</li>
</ul>
</li>
</ul>


<p><a name="USB_DADDR"></a></p>

<h5>Адрес устройства USB (device address, <code>USB_DADDR</code>)</h5>

<pre><code>Смещение адреса:        0x4c
Значение после сброса:  0x0000
</code></pre>

<p><img src="reg_DADDR.png"></p>

<ul>
<li>7: <br> <code>EF</code> <br>
<strong>Вкл</strong> (enable function)

<ul>
<li>Включает USB. Если бит равен 0, то USB-транзакции не будут обрабатываться, независимо от состояния других регистров.</li>
</ul>
</li>
<li>6-0: <br> <code>ADD</code> <br>
<strong>USB-адрес устройства</strong> (device address)

<ul>
<li>Поле содержит адрес устройства, назначаемый хостом во время процеса перечисления.</li>
</ul>
</li>
</ul>


<p><a name="USB_BTABLE"></a></p>

<h5>Адрес таблицы буферов (buffer table address, <code>USB_BTABLE</code>)</h5>

<pre><code>Смещение адреса:        0x50
Значение после сброса:  0x0000
</code></pre>

<p><img src="reg_BTABLE.png"></p>

<p>Регистр содержит адрес таблицы дескрипторов буферов в специальной пакетной памяти. Младшие три бита должны быть нулями, так как записи в таблице должны быть выровнены по 8-байтной границе.</p>

<p><a name="epregs"></a></p>

<h4>23.5.2. Регистры Конечных точек</h4>

<p><a name="USB_EPnR"></a></p>

<h5>Регистры КТ-n, n=[0..7] (USB endpoint n register, <code>USB_EPnR</code>)</h5>

<pre><code>Смещение адреса:        0x00, 0x04, 0x08, 0x0c,
                        0x10, 0x14, 0x18, 0x1c
Значение после сброса:  0x0000
</code></pre>

<p><img src="reg_EPnR.png"></p>

<p>При сбросе регистров через бит FRES регистра CNTR, биты CTR_RX и CTR_TX не сбрасываются, чтобы не пропустить оповещение об успешной транзакции, которое может случиться сразу после сброса.</p>

<p><em>Желательно избегать операции чтения-изменения-записи в эти регистры, так как между чтением и записью некоторые биты могут быть изменены аппаратно. Для каждого из изменяемых аппаратно битов предусмотрено специальное значение, которое их не изменяет. Рекомендуется менять регистры простой инструкцией загрузки (ldr) с установкой битов, которе не требуется менять, в их &ldquo;инвариантные&rdquo; значения.</em></p>

<ul>
<li>15: <br> <code>CTR_RX</code> <br>
<strong>Успешный приём</strong> (correct transfer rx)

<ul>
<li>Устанавливается аппаратно при успешной OUT/SETUP транзакции. ПО может только очистить этот бит, записав 0.</li>
</ul>
</li>
<li>14: <br> <code>DTOG_RX</code> <br>
<strong>Переключаемый бит приёма</strong> (data toggle rx)

<ul>
<li>Переключается аппаратно, после того как хосту отправлен ACK. Также используется для переключения буферов, если используется двойная буферизация (смотри Раздел 23.4.3.). Переключается записью 1.</li>
<li><strong>0</strong>: Данные передаются в пакете DATA0, если КТ не Изохронная.</li>
<li><strong>1</strong>: Данные передаются в пакете DATA1, если КТ не Изохронная.</li>
</ul>
</li>
<li>13-12: <br> <code>STAT_RX</code> <br>
<strong>Состояние при приёме</strong> (status rx)

<ul>
<li>Смотри Таблицу 173 ниже. Биты только переключаются записью в них 1.</li>
</ul>
</li>
<li>11: <br> <code>SETUP</code> <br>
<strong>Завершение SETUP-транзакции</strong> (setup transaction completed)

<ul>
<li>Обозначает, что последней была SETUP-транзакция. Актуально только для управляющих КТ.</li>
</ul>
</li>
<li>10-9: <br> <code>EP_TYPE</code> <br>
<strong>Тип Конечной точки</strong> (endpoint type)

<ul>
<li>Поле определяет поведение КТ. Смотри Таблицу 174 ниже. КТ-0 всегда должна быть управляющей.</li>
</ul>
</li>
<li>8: <br> <code>EP_KIND</code> <br>
<strong>Вариант Конечной точки</strong> (endpoint kind)

<ul>
<li>Назначение поля зависит от типа КТ (от поля EP_TYPE), смотри Таблицу 175 ниже.</li>
<li>DBL_BUF: на КТ включена двойная буферизация.</li>
<li>STATUS_OUT: значение устанавивает ПО для обозначения, что ожидается транзакция STATUS OUT. На другие OUT-транзакции, содержащие байты данных, отправляется STALL. Значение предназначено только для управляющих КТ.</li>
</ul>
</li>
<li>7: <br> <code>CTR_TX</code> <br>
<strong>Успешная отправка</strong> (correct transfer tx)

<ul>
<li>Устанавливается аппаратно при успешной IN-транзакции. ПО может только очистить этот бит, записав 0.</li>
</ul>
</li>
<li>6: <br> <code>DTOG_TX</code> <br>
<strong>Переключаемый бит отправки</strong> (data toggle tx)

<ul>
<li>Переключается аппаратно, после того как от хоста получен ACK. Также используется для переключения буферов, если используется двойная буферизация (смотри Раздел 23.4.3.). Переключается записью 1.</li>
<li><strong>0</strong>: Данные передаются в пакете DATA0, если КТ не Изохронная.</li>
<li><strong>1</strong>: Данные передаются в пакете DATA1, если КТ не Изохронная.</li>
</ul>
</li>
<li>5-4: <br> <code>STAT_TX</code> <br>
<strong>Состояние при отправке</strong> (status tx)

<ul>
<li>Смотри Таблицу 176 ниже. Биты только переключаются записью в них 1.</li>
</ul>
</li>
<li>3-0: <br> <code>EA</code> <br>
<strong>Адрес Конечной точки</strong> (endpoint address)

<ul>
<li>ПО должно записать адрес КТ в это поле до её включения.</li>
</ul>
</li>
</ul>


<p><img src="tab_173.png"></p>

<p><img src="tab_174.png"></p>

<p><img src="tab_175.png"></p>

<p><img src="tab_176.png"></p>

<p><a name="table"></a></p>

<h4>23.5.3. Таблица дескрипторов буферов</h4>

<p>Хоть таблица и расположена в пакетной памяти, записи в ней могут рассмотриваться как дополниельные регистры, служащие для настройки Пакетных буферов.</p>

<p>Ввиду ограничений моста APB, доступ к пакеной памяти происходит по адресам, выровненным по 32-битной границе.</p>

<p>Чтобы получить правильный адрес для использования в приложении, адрес пакетной памяти нужно умножить на 2. Первый адрес пакетной памяти — <code>0x40006000</code>.</p>

<p>Для Конечных точек с двойной буферизацией, в том числе Изохронных, регистры противоположного направления используются для описания второго буфера. Синонимы для регистров TX: TX_0, RX_0; для регистров RX: TX_1, RX_1.</p>

<p><a name="USB_ADDRn_TX"></a></p>

<h5>Адрес буфера отправки n (<code>USB_ADDRn_TX</code>)</h5>

<pre><code>Смещение адреса:    [USB_BTABLE] + (n*8 + 0)*2
Локальное смещение: [USB_BTABLE] + (n*8 + 0)
</code></pre>

<p><img src="reg_ADDRn_TX.png"></p>

<p>Указывает на начало Пакетного буфера, содержащего данные для отправки по IN-транзакции.</p>

<p><a name="USB_COUNTn_TX"></a></p>

<h5>Количество отправляемых байтов n (<code>USB_COUNTn_TX</code>)</h5>

<pre><code>Смещение адреса:    [USB_BTABLE] + (n*8 + 2)*2
Локальное смещение: [USB_BTABLE] + (n*8 + 2)
</code></pre>

<p><img src="reg_COUNTn_TX.png"></p>

<p>В регистр записывается количество байтов, которые нужно отправить по IN-транзакции.</p>

<p><a name="USB_ADDRn_RX"></a></p>

<h5>Адрес буфера приёма n (<code>USB_ADDRn_RX</code>)</h5>

<pre><code>Смещение адреса:    [USB_BTABLE] + (n*8 + 4)*2
Локальное смещение: [USB_BTABLE] + (n*8 + 4)
</code></pre>

<p><img src="reg_ADDRn_RX.png"></p>

<p>Указывает на начало Пакетного буфера, в который будут записываться принимаемые OUT/SETUP-транзакции данные.</p>

<p><a name="USB_COUNTn_RX"></a></p>

<h5>Количество принятых байтов n (<code>USB_COUNTn_RX</code>)</h5>

<pre><code>Смещение адреса:    [USB_BTABLE] + (n*8 + 6)*2
Локальное смещение: [USB_BTABLE] + (n*8 + 6)
</code></pre>

<p><img src="reg_COUNTn_RX.png"></p>

<p>Регистр содержит два значения:</p>

<ul>
<li>размер буфера для принимаемых данных</li>
<li>и количество принятых байтов.</li>
</ul>


<p>Размер буфера в зависимости от значения полей может быть определён по Таблице 177 ниже.</p>

<ul>
<li>15: <br> <code>BLSIZE</code> <br>
<strong>Размер блока</strong> (block size)

<ul>
<li><strong>0</strong>: Размер блока — 2 байта.</li>
<li><strong>1</strong>: Размер блока — 32 байта.</li>
</ul>
</li>
<li>14-10: <br> <code>NUM_BLOCK</code> <br>
<strong>Количество блоков</strong> (number of blocks)

<ul>
<li>В поле указывается размер буфера в блоках.</li>
</ul>
</li>
<li>9-0: <br> <code>COUNTn_RX</code> <br>
<strong>Количество принятых байтов</strong> (reception byte count)

<ul>
<li>Счётчик байтов, принятых по OUT/SETUP-транзакции.</li>
</ul>
</li>
</ul>


<p><img src="tab_177.png"></p>

<p><a name="regmap"></a></p>

<h4>23.5.4. Карта регистров USB</h4>

<p><img src="reg_map.png"></p>
